/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech) (6.2.0).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package com.bookandgo.reservation.infra.api.rest.controllers;

import com.bookandgo.reservation.infra.api.dto.ApplicablePriceDTO;
import org.springframework.format.annotation.DateTimeFormat;
import com.bookandgo.reservation.infra.api.dto.ErrorListDTO;
import java.time.LocalDateTime;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.Parameters;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.multipart.MultipartFile;

import jakarta.validation.Valid;
import jakarta.validation.constraints.*;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import jakarta.annotation.Generated;

@Generated(value = "org.openapitools.codegen.languages.SpringCodegen", date = "2025-03-20T10:35:07.434864600+01:00[Europe/Madrid]")
@Validated
@Tag(name = "prices", description = "the prices API")
@RequestMapping("${openapi.exampleTest2022.base-path:/$}")
public interface PricesApi {

    default Optional<NativeWebRequest> getRequest() {
        return Optional.empty();
    }

    /**
     * GET /prices/{brandId}/priceList/{productId} : Allows to get the applicabe price list for a concrete product
     *
     * @param authorization Authorization security header (required)
     * @param brandId Brand Id (required)
     * @param productId Product Id (required)
     * @param date Date to get applicable price (required)
     * @param xB3TraceId Overall ID of the trace, shared by every span in the trace.   The value is 64 or 128 bits long (optional)
     * @param xB3SpanId Position of the current operation in the trace tree.  The value is 64 bits long.  Do not interpret the value: it may or may not be derived from the value of the TraceId. (optional)
     * @param xB3ParentSpanId Position of the parent operation in the trace tree.  The value is 64 bits long.   The value is omitted when the span is the root of the trace tree (optional)
     * @param xB3Sampled Sampling decision.  Sampling is a mechanism to reduce the volume of data in the tracing system. In B3, sampling applies consistently per-trace: once the sampling decision is made, the same value must be consistently sent downstream. This means that either all or no spans share a trace ID.  The possible values are:  - 0 &#x3D; Deny - 1 &#x3D; Accept - d &#x3D; Debug (optional)
     * @return OK (status code 200)
     *         or Bad request (status code 400)
     *         or Unauthorized (status code 401)
     *         or Unsupported Media Type (status code 415)
     *         or Internal server error (status code 500)
     *         or Service unavailable (status code 503)
     *         or Too Many Requests (status code 504)
     */
    @Operation(
        operationId = "getApplicablePricesByProduct",
        summary = "Allows to get the applicabe price list for a concrete product",
        tags = { "Applicable Prices" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ApplicablePriceDTO.class))
            }),
            @ApiResponse(responseCode = "400", description = "Bad request", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorListDTO.class))
            }),
            @ApiResponse(responseCode = "401", description = "Unauthorized", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorListDTO.class))
            }),
            @ApiResponse(responseCode = "415", description = "Unsupported Media Type", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorListDTO.class))
            }),
            @ApiResponse(responseCode = "500", description = "Internal server error", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorListDTO.class))
            }),
            @ApiResponse(responseCode = "503", description = "Service unavailable", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorListDTO.class))
            }),
            @ApiResponse(responseCode = "504", description = "Too Many Requests", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorListDTO.class))
            })
        },
        security = {
            @SecurityRequirement(name = "basicAuth")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/prices/{brandId}/priceList/{productId}",
        produces = { "application/json" }
    )
    default ResponseEntity<ApplicablePriceDTO> getApplicablePricesByProduct(
        @NotNull @Parameter(name = "Authorization", description = "Authorization security header", required = true) @RequestHeader(value = "Authorization", required = true) String authorization,
        @Parameter(name = "brandId", description = "Brand Id", required = true) @PathVariable("brandId") Integer brandId,
        @Parameter(name = "productId", description = "Product Id", required = true) @PathVariable("productId") Long productId,
        @NotNull @Parameter(name = "date", description = "Date to get applicable price", required = true) @Valid @RequestParam(value = "date", required = true) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime date,
        @Parameter(name = "X-B3-TraceId", description = "Overall ID of the trace, shared by every span in the trace.   The value is 64 or 128 bits long") @RequestHeader(value = "X-B3-TraceId", required = false) String xB3TraceId,
        @Parameter(name = "X-B3-SpanId", description = "Position of the current operation in the trace tree.  The value is 64 bits long.  Do not interpret the value: it may or may not be derived from the value of the TraceId.") @RequestHeader(value = "X-B3-SpanId", required = false) String xB3SpanId,
        @Parameter(name = "X-B3-ParentSpanId", description = "Position of the parent operation in the trace tree.  The value is 64 bits long.   The value is omitted when the span is the root of the trace tree") @RequestHeader(value = "X-B3-ParentSpanId", required = false) String xB3ParentSpanId,
        @Parameter(name = "X-B3-Sampled", description = "Sampling decision.  Sampling is a mechanism to reduce the volume of data in the tracing system. In B3, sampling applies consistently per-trace: once the sampling decision is made, the same value must be consistently sent downstream. This means that either all or no spans share a trace ID.  The possible values are:  - 0 = Deny - 1 = Accept - d = Debug") @RequestHeader(value = "X-B3-Sampled", required = false) String xB3Sampled
    ) {
        getRequest().ifPresent(request -> {
            for (MediaType mediaType: MediaType.parseMediaTypes(request.getHeader("Accept"))) {
                if (mediaType.isCompatibleWith(MediaType.valueOf("application/json"))) {
                    String exampleString = "{ \"productId\" : 35455, \"brandId\" : 1, \"priceList\" : 2, \"date\" : \"2020-07-16T16:55:42.000Z\", \"price\" : 35.5 }";
                    ApiUtil.setExampleResponse(request, "application/json", exampleString);
                    break;
                }
            }
        });
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }

}
